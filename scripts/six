#!/usr/bin/env python2.5
# vim: sw=4 sts=4 et fileencoding=latin1 nomod

'''Run the doctests in all of the listed modules.  If a module search path is
given with the --path option, then only that path is searched for the modules
listed on the command line.  If the --recursive option is given, then any
packages listed on the command line are tested, and also all modules and
packages contained within them.
'''

import sys
sys.path.pop(0)
import locale
import os
import os.path
import cPickle as pickle
import errno
from optparse import OptionParser
import six.parse as parse
from six.test import run_doctest
from six.input import InputError
from six.model import Model, ModelParser
from six.node import name_imatches, in_place
from six.links import from_node
from six.keyword import keyed_with
from six.reports.dump import report_dump, report_dump_getopt
from six.reports.book import report_book, report_book_getopt
from six.reports.email import report_email, report_email_getopt
from six.reports.phone import report_phone, report_phone_getopt

def main():
    locale.setlocale(locale.LC_ALL, '')
    lang, enc = locale.getlocale()
    path = os.path.join(os.environ['HOME'], 'me', 'contacts', 'nlist')
    cache = os.path.join(os.path.dirname(path),
                         '.six-cache-' + os.path.basename(path))
    reports = dict([(name[7:], (obj, globals().get(name + '_getopt')))
                            for name, obj in globals().iteritems()
                            if callable(obj) and name.startswith('report_')])
    assert reports
    op = OptionParser(usage=
        'Usage: %prog --doctest [doctest-options] [module ...]\n'
        '       %prog [-r|--report=REPORT] [report-options] [expr]')
    op.add_option('--doctest', action='callback', callback=opt_doctest,
                  help='run doctests (see --doctest --help for options)')
    op.add_option('-l', '--local',
                  action='store', type='string', dest='local',
                  help='output addresses and telephone numbers relative to '
                       'the country or area named LOCAL')
    op.add_option('-o', '--output',
                  action='store', type='string', dest='output_path',
                  help='write output to file pathname instead of stdout')
    try:
        # Parse the first argument(s) as the report type option.  If absent,
        # select the default report.
        args = sys.argv[1:]
        if args and args[0].startswith('-r='):
            arg = args.pop(0)
            report = arg[3:]
        elif args and args[0].startswith('--report='):
            arg = args.pop(0)
            report = arg[9:]
        elif args and args[0] in ('-r', '--report'):
            arg = args.pop(0)
            report = args.pop(0) if args else None
        else:
            report = 'dump'
        if not report:
            raise ArgError('missing report name', arg=arg)
        try:
            report, getopt = reports[report]
        except KeyError:
            raise ArgError('unsupported report', arg=report)
        # Call the report's getopt function, if available, to populate the
        # option parser with the report-specific options.
        if getopt:
            getopt(op)
        # Parse the command-line options.
        options, args = op.parse_args(args)
        # If the cache exists, attempt to read the model from it.  In the event
        # that it fails to read correctly, silently skip it and proceed to
        # compile the model from source, then save the compiled model in the
        # cache.
        model = None
        if (    os.path.exists(cache) and
                (os.stat(path).st_mtime <= os.stat(cache).st_mtime) and
                (os.stat(sys.argv[0]).st_mtime <= os.stat(cache).st_mtime)):
            try:
                model = pickle.load(file(cache, 'r'))
            except StandardError:
                pass
        if model is None:
            model = Model()
            parser = ModelParser(model)
            try:
                for block in parse.blocks(parse.remove_comments(parse.lines(path))):
                    parser.parse_block(block)
                parser.finish_parsing()
            finally:
                parser.finalise()
            try:
                os.remove(cache)
            except OSError, e:
                if e.errno != errno.ENOENT:
                    raise
            orl = sys.getrecursionlimit()
            sys.setrecursionlimit(4000)
            pickle.dump(model, file(cache, 'w'))
            sys.setrecursionlimit(orl)
        # Determine the local location for relative rewriting of addresses and
        # telephone numbers.  If not given as a command-line option, then look
        # in an environment variable.
        local = None
        localn = None
        if options.local:
            try:
                local = model.lookup_place(options.local)
            except LookupError, e:
                raise ArgError(e, arg=options.local)
        elif 'SIX_LOCAL' in os.environ:
            try:
                local = model.lookup_place(os.environ['SIX_LOCAL'])
            except LookupError, e:
                raise EnvError(e, var='SIX_LOCAL')
        # Parse command-line args as search expression.  If no args, then
        # select all nodes.
        pred = None
        if len(args):
            for arg in args:
                if arg.startswith('='):
                    try:
                        kw = model.keyword(arg[1:])
                    except LookupError:
                        raise ArgError('no such keyword', arg=arg)
                    p = keyed_with(kw)
                elif arg.startswith('in:'):
                    try:
                        place = model.lookup_place(arg[3:])
                    except LookupError, e:
                        raise ArgError(e, arg=arg[3:])
                    p = in_place(place)
                else:
                    p = name_imatches(arg.decode(enc))
                if pred is None:
                    pred = p
                else:
                    pred = pred & p
        # Print the selected report.
        report(options, model, pred, local)
    except InputError, e:
        print >>sys.stderr, '%s: %s' % (os.path.basename(sys.argv[0]), str(e))
        sys.exit(1)

def opt_doctest(option, opt_str, value, parser):
    op = OptionParser(usage=r'Usage: %prog --doctest [options] [module ...]')
    op.add_option('-v', '--verbose', action='store_true', dest='verbose',
                  help='print all tests and results as they are run')
    op.add_option('-r', '--recursive', action='store_true', dest='recursive',
                  help='recurse through packages')
    op.add_option('-p', '--path', action='store', type='string', dest='path',
                  help='search for modules in directory PATH')
    options, args = op.parse_args(args=parser.rargs)
    modules = args
    if not modules:
        modules = ['six']
        options.recursive = True
    status = 0
    for module_name in modules:
        if not run_doctest(module_name, options.path, recurse=options.recursive,
                           verbose=options.verbose):
            status = 1
    sys.exit(status)

class ArgError(InputError):

    def __init__(self, msg, arg=None):
        StandardError.__init__(self, msg)
        self.arg = arg

    def __str__(self):
        r = []
        if self.arg is not None:
            r.append(repr(self.arg))
        r.append(StandardError.__str__(self))
        return ': '.join(r)

class EnvError(InputError):

    def __init__(self, msg, var=None):
        StandardError.__init__(self, msg)
        self.var = var

    def __str__(self):
        r = []
        if self.var is not None:
            r.append('env var %s' % self.var)
        r.append(StandardError.__str__(self))
        return ': '.join(r)

if __name__ == '__main__':
    main()
