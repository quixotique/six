#!/usr/bin/env python2.5
# vim: sw=4 sts=4 et fileencoding=latin1 nomod

'''Run the doctests in all of the listed modules.  If a module search path is
given with the --path option, then only that path is searched for the modules
listed on the command line.  If the --recursive option is given, then any
packages listed on the command line are tested, and also all modules and
packages contained within them.
'''

import sys
sys.path.pop(0)
import locale
import os
import os.path
import cPickle as pickle
import errno
from optparse import OptionParser
import six.parse as parse
from six.test import run_doctest
from six.input import InputError
from six.model import Model, ModelParser
from six.node import name_imatches, NamedNode, in_place
from six.links import from_node
from six.keyword import keyed_with
from six.reports.dump import report_dump, report_dump_getopt
from six.reports.book import report_book, report_book_getopt
from six.reports.email import report_email, report_email_getopt
from six.reports.phone import report_phone, report_phone_getopt

def main():
    locale.setlocale(locale.LC_ALL, '')
    lang, enc = locale.getlocale()
    reports = dict([(name[7:], (obj, globals().get(name + '_getopt')))
                            for name, obj in globals().iteritems()
                            if callable(obj) and name.startswith('report_')])
    assert reports
    assert 'dump' in reports
    def select_report(option, optstr, value, parser):
        r'''When the --report option is parsed, call the report's getopt
        function, which may populate the option parser with more options.
        '''
        parser.values.report = value
        getopt_func = reports[value][1]
        if getopt_func:
            getopt_func(parser)
    op = OptionParser(usage=
        'Usage: %prog --doctest [doctest-options] [module ...]\n'
        '       %prog [options] [expr]')
    op.add_option('--doctest', action='callback', callback=opt_doctest,
                  help='run doctests (see --doctest --help for options)')
    op.add_option('-l', '--local',
                  action='store', type='string', dest='local',
                  help='output addresses and telephone numbers relative to '
                       'the country or area named LOCAL')
    op.add_option('-r', '--report',
                  action='callback', type='choice', callback=select_report,
                  choices=sorted(reports),
                  help='select output report')
    op.add_option('-o', '--output',
                  action='store', type='string', dest='output_path',
                  help='write output to file pathname instead of stdout')
    op.set_defaults(report='dump', encoding=enc)
    options, args = op.parse_args()
    path = os.path.join(os.environ['HOME'], 'me', 'contacts', 'nlist')
    cache = os.path.join(os.path.dirname(path),
                         '.six-cache-' + os.path.basename(path))
    # If the cache exists, attempt to read the model from it.  In the event
    # that it fails to read correctly, silently skip it and proceed to compile
    # the model from source, then save the compiled model in the cache.
    model = None
    if (    os.path.exists(cache) and
            (os.stat(path).st_mtime <= os.stat(cache).st_mtime) and
            (os.stat(sys.argv[0]).st_mtime <= os.stat(cache).st_mtime)):
        try:
            model = pickle.load(file(cache, 'r'))
        except StandardError:
            pass
    if model is None:
        model = Model()
        parser = ModelParser(model)
        try:
            for block in parse.blocks(parse.remove_comments(parse.lines(path))):
                parser.parse_block(block)
            parser.finish_parsing()
        except InputError, e:
            print >>sys.stderr, '%s: %s' % (os.path.basename(sys.argv[0]),
                                            str(e))
            sys.exit(1)
        finally:
            parser.finalise()
        try:
            os.remove(cache)
        except OSError, e:
            if e.errno != errno.ENOENT:
                raise
        orl = sys.getrecursionlimit()
        sys.setrecursionlimit(4000)
        pickle.dump(model, file(cache, 'w'))
        sys.setrecursionlimit(orl)
    # Parse command-line args as search expression.  If no args, then select
    # all nodes.
    try:
        local = None
        localn = None
        if options.local:
            try:
                local = model.lookup_place(options.local)
            except LookupError, e:
                raise ArgError(e, arg=options.local)
        elif 'SIX_LOCAL' in os.environ:
            try:
                local = model.lookup_place(os.environ['SIX_LOCAL'])
            except LookupError, e:
                raise EnvError(e, var='SIX_LOCAL')
        pred = None
        if len(args):
            for arg in args:
                if arg.startswith('='):
                    try:
                        kw = model.keyword(arg[1:])
                    except LookupError:
                        raise ArgError('no such keyword', arg=arg)
                    p = keyed_with(kw)
                elif arg.startswith('in:'):
                    try:
                        place = model.lookup_place(arg[3:])
                    except LookupError, e:
                        raise ArgError(e, arg=arg[3:])
                    p = instance_p(NamedNode) & in_place(place)
                else:
                    p = name_imatches(arg.decode(enc))
                if pred is None:
                    pred = p
                else:
                    pred = pred & p
        # Print the selected report.
        reports[options.report][0](options, model, pred, local)
    except InputError, e:
        print >>sys.stderr, '%s: %s' % (os.path.basename(sys.argv[0]), str(e))
        sys.exit(2)

def opt_doctest(option, opt_str, value, parser):
    op = OptionParser(usage=r'Usage: %prog --doctest [options] [module ...]')
    op.add_option('-v', '--verbose', action='store_true', dest='verbose',
                  help='print all tests and results as they are run')
    op.add_option('-r', '--recursive', action='store_true', dest='recursive',
                  help='recurse through packages')
    op.add_option('-p', '--path', action='store', type='string', dest='path',
                  help='search for modules in directory PATH')
    options, args = op.parse_args(args=parser.rargs)
    modules = args
    if not modules:
        modules = ['six']
        options.recursive = True
    status = 0
    for module_name in modules:
        if not run_doctest(module_name, options.path, recurse=options.recursive,
                           verbose=options.verbose):
            status = 1
    sys.exit(status)

class ArgError(InputError):

    def __init__(self, msg, arg=None):
        StandardError.__init__(self, msg)
        self.arg = arg

    def __str__(self):
        r = []
        if self.arg is not None:
            r.append(repr(self.arg))
        r.append(StandardError.__str__(self))
        return ': '.join(r)

class EnvError(InputError):

    def __init__(self, msg, var=None):
        StandardError.__init__(self, msg)
        self.var = var

    def __str__(self):
        r = []
        if self.var is not None:
            r.append('env var %s' % self.var)
        r.append(StandardError.__str__(self))
        return ': '.join(r)

if __name__ == '__main__':
    main()
