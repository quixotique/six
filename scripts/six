#!/usr/bin/env python2.5
# vim: sw=4 sts=4 et fileencoding=latin1 nomod

'''Run the doctests in all of the listed modules.  If a module search path is
given with the --path option, then only that path is searched for the modules
listed on the command line.  If the --recursive option is given, then any
packages listed on the command line are tested, and also all modules and
packages contained within them.
'''

import sys
sys.path.pop(0)
import locale
import codecs
import os
import os.path
import cPickle as pickle
import errno
from optparse import OptionParser
from collections import defaultdict
import six.parse as parse
from six.test import run_doctest
from six.input import InputError
from six.model import *
from six.links import *
from six.sort import *
from itertools import ifilter

def main():
    locale.setlocale(locale.LC_ALL, '')
    lang, enc = locale.getlocale()
    op = OptionParser(usage=
        'Usage: %prog --doctest [doctest-options] [module ...]\n'
        '       %prog [options] [expr]')
    op.add_option('--doctest', action='callback', callback=opt_doctest,
                  help='run doctests (see --doctest --help for options)')
    op.add_option('-l', '--local',
                  action='store', type='string', dest='local',
                  help='output addresses and telephone numbers relative to '
                       'the country or area named LOCAL')
    op.add_option('-r', '--report',
                  action='store', type='string', dest='report',
                  help='select output report, REPORT is one of: dump, phone')
    op.add_option('-a', '--all',
                  action='store_true', dest='all',
                  help='print all possible values')
    op.add_option('-e', '--encode',
                  action='store', dest='string', dest='encoding',
                  help='use ENCODE as output encoding')
    op.set_defaults(report='dump')
    options, args = op.parse_args()
    path = os.path.join(os.environ['HOME'], 'me', 'contacts', 'nlist')
    cache = os.path.join(os.path.dirname(path),
                         '.six-cache-' + os.path.basename(path))
    # If the cache exists, attempt to read the model from it.  In the event
    # that it fails to read correctly, silently skip it and proceed to compile
    # the model from source, then save the compiled model in the cache.
    model = None
    if (    os.path.exists(cache) and
            (os.stat(path).st_mtime <= os.stat(cache).st_mtime) and
            (os.stat(sys.argv[0]).st_mtime <= os.stat(cache).st_mtime)):
        try:
            model = pickle.load(file(cache, 'r'))
        except StandardError:
            pass
    if model is None:
        model = Model()
        parser = ModelParser(model)
        try:
            for block in parse.blocks(parse.remove_comments(parse.lines(path))):
                parser.parse_block(block)
            parser.finish_parsing()
        except InputError, e:
            print >>sys.stderr, '%s: %s' % (os.path.basename(sys.argv[0]),
                                            str(e))
            sys.exit(1)
        finally:
            parser.finalise()
        try:
            os.remove(cache)
        except OSError, e:
            if e.errno != errno.ENOENT:
                raise
        orl = sys.getrecursionlimit()
        sys.setrecursionlimit(4000)
        pickle.dump(model, file(cache, 'w'))
        sys.setrecursionlimit(orl)
    # Parse command-line args as search expression.  If no args, then select
    # all nodes.
    try:
        local = None
        localn = None
        if options.local:
            try:
                local = model.lookup_place(options.local)
            except LookupError, e:
                raise ArgError(e, arg=options.local)
        elif 'SIX_LOCAL' in os.environ:
            try:
                local = model.lookup_place(os.environ['SIX_LOCAL'])
            except LookupError, e:
                raise EnvError(e, var='SIX_LOCAL')
        pred = None
        if len(args):
            for arg in args:
                if arg.startswith('='):
                    try:
                        kw = model.keyword(arg[1:])
                    except LookupError:
                        raise ArgError('no such keyword', arg=arg)
                    p = keyed_with(kw)
                elif arg.startswith('in:'):
                    try:
                        place = model.lookup_place(arg[3:])
                    except LookupError, e:
                        raise ArgError(e, arg=arg[3:])
                    p = from_node(NamedNode) & in_place(place)
                else:
                    p = name_imatches(arg.decode(enc))
                if pred is None:
                    pred = p
                else:
                    pred = pred & p
        # Print the selected report.
        try:
            report = globals()['report_' + options.report]
        except KeyError:
            raise ArgError('unsupported report %r' % options.report)
        report(options, model, pred, local, options.encoding or enc)
    except InputError, e:
        print >>sys.stderr, '%s: %s' % (os.path.basename(sys.argv[0]), str(e))
        sys.exit(2)

def opt_doctest(option, opt_str, value, parser, *args, **kwargs):
    op = OptionParser(usage=r'Usage: %prog --doctest [options] [module ...]')
    op.add_option('-v', '--verbose', action='store_true', dest='verbose',
                  help='print all tests and results as they are run')
    op.add_option('-r', '--recursive', action='store_true', dest='recursive',
                  help='recurse through packages')
    op.add_option('-p', '--path', action='store', type='string', dest='path',
                  help='search for modules in directory PATH')
    options, args = op.parse_args(args=parser.rargs)
    modules = args
    if not modules:
        modules = ['six']
        options.recursive = True
    status = 0
    for module_name in modules:
        if not run_doctest(module_name, options.path, recurse=options.recursive,
                           verbose=options.verbose):
            status = 1
    sys.exit(status)

class InputError(StandardError):
    pass

class ArgError(InputError):

    def __init__(self, msg, arg=None):
        StandardError.__init__(self, msg)
        self.arg = arg

    def __str__(self):
        r = []
        if self.arg is not None:
            r.append(repr(self.arg))
        r.append(StandardError.__str__(self))
        return ': '.join(r)

class EnvError(InputError):

    def __init__(self, msg, var=None):
        StandardError.__init__(self, msg)
        self.var = var

    def __str__(self):
        r = []
        if self.var is not None:
            r.append('env var %s' % self.var)
        r.append(StandardError.__str__(self))
        return ': '.join(r)

def report_dump(options, model, predicate, local, encoding):
    # If no predicate given, then select all people, organisations, and
    # families.
    if predicate is None:
        predicate = from_node(Person) | from_node(Company) | from_node(Family)
    # Populate the top level of the report with all the nodes that satisfy the
    # predicate.
    sorter = Sorter()
    sorter.update(model.nodes(predicate))
    # Add nodes that are implied by the predicate:
    # - A selected department imples its parent company (and intermediate
    #   departments).
    # - A selected family implies all its members, and an organisation
    #   (company or department) implies all the people who work for it.
    for node in list(sorter):
        sorter.update((tup[-1] for tup in node.find_nodes(
                            incoming & is_link(Has_department),
                            select=lambda n: isinstance(n, Organisation))))
    for node in list(sorter):
        sorter.update(node.nodes(incoming &
                                 (is_link(Belongs_to) | is_link(Works_at))))
    # Remove top-level entries for certain people.
    seen = set(sorter)
    see_in_family = defaultdict(set)
    see_in_org = defaultdict(set)
    for node in seen:
        if isinstance(node, Person):
            person = node
            # People who are heads of organisations always get their own entry.
            works_at = list(person.links(outgoing & is_link(Works_at)))
            if [wat for wat in works_at if wat.is_head]:
                continue
            # Omit top-level entries for people who belong to a single family
            # or who work for a single organisation, if the family/org has its
            # own top-level entry.  Instead, their details will get listed
            # within that entry.
            families = list(person.nodes(outgoing & is_link(Belongs_to)))
            if len(families) == 1 and families[0] in sorter:
                sorter.discard(person)
                see_in_family[families[0]].add(person)
            elif len(works_at) == 1 and works_at[0].org in sorter:
                sorter.discard(person)
                see_in_org[works_at[0].org].add(person)
    # Form the sorted index of all the top-level entries in the report.
    sorted = list(sorter.sorted())
    # Remove top-level entries that reference a nearby entry.  The horizon is a
    # heuristic for how far we expect a user will search around for an entry
    # which is out of order.
    horizon = 8
    for i, item in enumerate(sorted):
        if item is item.single:
            lim = 0
            for j in xrange(i - 1, -1, -1):
                if sorted[j].sortkey[:3] != item.sortkey[:3]:
                    break
                if sorted[j].node:
                    lim += 1
                    if lim > horizon:
                        break
                    if sorted[j].node is item.node:
                        sorted[j].node = None
    # Remove top-level entries that reference the same entry as another nearby,
    # prior entry.
    for i, item in enumerate(sorted):
        if item is not item.single:
            lim = 0
            for j in xrange(i - 1, -1, -1):
                if sorted[j].sortkey[:3] != item.sortkey[:3]:
                    break
                if sorted[j].node:
                    lim += 1
                    if lim > horizon:
                        break
                    if sorted[j].node is item.node:
                        item.node = None
                        break
    # Now format the report.
    from six.output import Treebuf
    tree = Treebuf(local=local)
    for item in sorted:
        if item.node is None:
            pass
        elif item is not item.single:
            tree.nl()
            tree.add(item.key, ' -> ')
            dump_name(item.single.node, tree, show_aka=False)
        elif isinstance(item.node, Person):
            tree.nl()
            dump_name(item.node, tree)
            dump_person(item.node, tree.sub(), seen)
        elif isinstance(item.node, Family):
            tree.nl()
            dump_name(item.node, tree)
            dump_family(item.node, tree.sub(),
                        seen - see_in_family.get(item.node, set()))
        elif isinstance(item.node, Department):
            tree.nl()
            dump_name(item.node, tree)
            dump_organisation(item.node, tree.sub(),
                              seen - see_in_org.get(item.node, set()))
        elif isinstance(item.node, Organisation):
            tree.nl()
            dump_name(item.node, tree)
            dump_organisation(item.node, tree.sub(),
                              seen - see_in_org.get(item.node, set()))
    print unicode(tree).encode(encoding, 'replace')

def report_email(options, model, predicate, local, encoding):
    if predicate is None:
        predicate = from_node(Person) | from_node(Company) | from_node(Family)
        options.all = False
    sorter = Sorter()
    sorter.update(model.nodes(predicate))
    # Remove entries for families for which one or more of the heads was found.
    for person in filter(lambda node: isinstance(node, Person), sorter):
        for belongs_to in person.links(outgoing & is_link(Belongs_to)):
            if belongs_to.is_head:
                sorter.discard(belongs_to.family)
    for item in sorter.sorted():
        if item is not item.single:
            continue
        node = item.node
        print_emails(node, encoding)
        stop = lambda node: False
        if isinstance(node, Organisation):
            pred = ((incoming & is_link(Works_at)) |
                    (outgoing & is_link(Belongs_to)) |
                    (outgoing & is_link(Resides_at)))
            if not options.all:
                stop = lambda node: isinstance(node, Person)
        elif isinstance(node, Family):
            pred = ((outgoing & is_link(Works_at)) |
                    (incoming & is_link(Belongs_to)) |
                    (outgoing & is_link(Resides_at)))
            if not options.all:
                stop = lambda node: isinstance(node, Organisation)
        else:
            assert isinstance(node, Person)
            pred = ((outgoing & is_link(Belongs_to)) |
                    (outgoing & is_link(Resides_at)) |
                    (outgoing & is_link(Works_at)))
            if not options.all:
                stop = lambda node: isinstance(node, Organisation)
        for tup in sorted(node.find_nodes(pred, stop=stop), key=len):
            print_emails(tup[-1], encoding)

def print_emails(node, encoding):
    name = None
    if isinstance(node, NamedNode):
        name = unicode(node)
    elif isinstance(node, Link):
        if hasattr(node, 'person'):
            name = unicode(node.person)
        elif hasattr(node, 'who'):
            name = unicode(node.who)
        elif hasattr(node, 'org'):
            name = unicode(node.org)
    printed = 0
    for addr in node.nodes(outgoing & is_link(Has_email)):
        print addr.format(name, encoding)
        printed += 1
    return printed

def report_phone(options, model, predicate, local, encoding):
    if predicate is None:
        predicate = ((from_node(Person) | from_node(Company)) & is_principal)
    tkw = {'fax': False, 'bold': True}
    sorter = Sorter()
    sorter.update(model.nodes(predicate))
    # Remove entries for families for which one or more of the heads was found.
    people = filter(lambda node: isinstance(node, Person), sorter)
    for person in people:
        for belongs_to in person.links(outgoing & is_link(Belongs_to)):
            if belongs_to.is_head:
                sorter.discard(belongs_to.family)
    from six.output import Treebuf
    tree = Treebuf(local=local)
    for item in sorter.sorted():
        if item is not item.single:
            continue
        node = item.node
        tree.nl()
        sub = tree.sub()
        if isinstance(node, Person):
            tree.add(node, underline=True)
            tree.nl()
            dump_comments(node, sub)
            telephones(node, sub, **tkw)
            for tup in node.find_nodes(
                    (outgoing & is_link(Belongs_to)) |
                    (outgoing & is_link(Resides_at)) |
                    (outgoing & is_link(Works_at))):
                telephones_qual(tup, sub, **tkw)
        elif isinstance(node, Family):
            tree.add(node, underline=True)
            tree.nl()
            dump_comments(node, sub)
            telephones(node, sub, **tkw)
            for tup in node.find_nodes(outgoing & is_link(Resides_at)):
                comment = []
                for node1 in tup:
                    if isinstance(node1, Resides_at):
                        comment.append(node1.residence.lines[0])
                telephones(tup[-1], sub, comment=', '.join(comment), **tkw)
            for link in sorted(node.links(incoming & is_link(Belongs_to))):
                sub.add(link.person.familiar_name(), underline=True)
                sub.nl()
                subsub = sub.sub()
                telephones(link, subsub, **tkw)
                telephones(link.person, subsub, **tkw)
                for tup in link.person.find_nodes(
                        (outgoing & is_link(Works_at)) |
                        (outgoing & is_link(Resides_at))):
                    telephones_qual(tup, subsub, **tkw)
        elif isinstance(node, Organisation):
            tree.add(node, underline=True)
            if isinstance(node, Department):
                link = node.link(incoming & is_link(Has_department))
                if link:
                    tree.add(', ', link.company)
            tree.nl()
            dump_comments(node, sub)
            telephones(node, sub, **tkw)
            telephones_org(node, sub, **tkw)
            for dept in node.nodes(outgoing & is_link(Has_department)):
                sub.add(dept, underline=True)
                sub.nl()
                subsub = sub.sub()
                telephones(dept, subsub, **tkw)
                telephones_org(dept, subsub, **tkw)
    print unicode(tree).encode(encoding, 'replace')

def telephones_org(org, tree, **tkw):
    for tup in org.find_nodes(outgoing & is_link(Resides_at)):
        comment = []
        for node1 in tup:
            if isinstance(node1, Resides_at):
                comment.append(node1.residence.lines[0])
        telephones(tup[-1], tree, comment=', '.join(comment), **tkw)
    for link in sorted(org.links(incoming & is_link(Works_at))):
        tree.add(link.person, underline=True)
        if link.position:
            tree.add(', ', link.position)
        tree.nl()
        sub = tree.sub()
        telephones(link, sub, **tkw)
        telephones(link.person, sub, **tkw)
        for tup in link.person.find_nodes(
                (outgoing & is_link(Belongs_to)) |
                (outgoing & is_link(Resides_at))):
            telephones_qual(tup, sub, **tkw)

def telephones_qual(tup, tree, **kwargs):
    qual = None
    comment = []
    for node in tup:
        if qual is None:
            dept = None
            if isinstance(node, Resides_at):
                qual = qual_home
                comment.append(node.residence.lines[0])
            elif isinstance(node, Works_at):
                qual = qual_work
                if node.position and node is tup[-1]:
                    comment.append(node.position)
                comment.append(unicode(node.org))
                if isinstance(node.org, Department):
                    dept = node.org
            elif isinstance(node, Department):
                dept = node
            elif isinstance(node, Has_department) and node.dept is dept:
                dept = None
                comment.append(unicode(node.company))
            # If we finished at a Department node, we'd better print the name
            # of the Company too.
            if dept:
                link = dept.link(incoming & is_link(Has_department))
                if link:
                    comment.append(unicode(link.company))
    telephones(tup[-1], tree, qual=qual, comment=', '.join(comment), **kwargs)

from six.multilang import multilang
from six.node import *
from six.person import *
from six.family import *
from six.org import *
from six.world import *
from six.address import *
from six.telephone import *
from six.email import *
from six.keyword import *
from six.data import *
from six.comment import *
from six.uniq import uniq

def add_name(node, tree, context=None):
    if context is not None:
        assert isinstance(context, Link)
    if isinstance(node, NamedNode):
        names = list(node.names())
        # When listing a person within their family's entry, omit the name as
        # it would appear in the family entry's head.
        if isinstance(node, Person) and isinstance(context, Belongs_to):
            assert context.person is node
            hn = node.family_head_name()
            names = [n for n in names if n != hn] or names
    else:
        names = [node]
    tree.add(names[0])
    if isinstance(node, Organisation):
        has_depts = list(node.links(incoming & is_link(Has_department)))
        assert len(has_depts) <= 1
        if has_depts:
            if has_depts[0] is not context:
                tree.add(', ')
                add_name(has_depts[0].company, tree, context)
    elif isinstance(node, Person):
        if isinstance(context, Works_at) and context.position:
            tree.add(', ', context.position)
    return names[1:]

def dump_name(node, tree, context=None, show_aka=True):
    aka_names = add_name(node, tree, context)
    tree.nl()
    if aka_names and show_aka:
        tree = tree.sub()
        for name in aka_names:
            tree.add('= ', name)
            tree.nl()

def dump_person(per, tree, seen=frozenset(), show_family=True, show_work=True,
                show_data=True):
    dump_comments(per, tree)
    if per.birthday():
        tree.add(multilang(en='Birthday', es='F.nac.'))
        tree.add(': ')
        tree.add(per.birthday())
        tree.nl()
    telephones(per, tree)
    dump_email(per, tree)
    dump_residences(per, tree)
    # Avoid endless recursion in dump_family() and dump_organisation().
    seen |= set([per])
    if show_family:
        for link in per.links(outgoing & is_link(Belongs_to)):
            refonly = link.family in seen
            if refonly:
                tree.add('-> ')
            else:
                tree.add('-- ')
            add_name(link.family, tree, link)
            tree.nl()
            sub = tree.sub()
            dump_comments(link, sub)
            telephones(link, sub)
            dump_email(link, sub)
            if not refonly:
                dump_family(link.family, sub, seen,
                            show_members=False, show_data=False)
    if show_work:
        for link in per.links(outgoing & is_link(Works_at)):
            refonly = link.org in seen
            if refonly:
                tree.add('-> ')
            else:
                tree.add('-- ')
            if link.position:
                tree.add(link.position, ', ')
            add_name(link.org, tree, link)
            tree.nl()
            sub = tree.sub()
            dump_comments(link, sub)
            telephones(link, sub)
            dump_email(link, sub)
            if not refonly:
                dump_organisation(link.org, sub, seen,
                                  show_workers=False, show_data=False)
    if show_data:
        dump_data(per, tree)

def dump_family(fam, tree, seen=frozenset(), show_members=True, show_data=True):
    # Avoid endless recursion in dump_person().
    seen |= set([fam])
    dump_comments(fam, tree)
    dump_residences(fam, tree)
    telephones(fam, tree)
    dump_email(fam, tree)
    if show_data:
        dump_data(fam, tree)
    if show_members:
        for link in sorted(fam.links(incoming & is_link(Belongs_to)),
                           key=lambda l: (not l.is_head,
                                          l.sequence or 0,
                                          l.person.sortkey())):
            if link.person in seen:
                tree.add('-> ')
                dump_name(link.person, tree, link, show_aka=False)
                sub = tree.sub()
                dump_comments(link, sub)
                telephones(link, sub)
                dump_email(link, sub)
            else:
                tree.add('-- ')
                dump_name(link.person, tree, link)
                sub = tree.sub()
                dump_comments(link, sub)
                telephones(link, sub)
                dump_email(link, sub)
                dump_person(link.person, sub, seen, show_family=False,
                            show_data=show_data)

def dump_organisation(com, tree, seen=frozenset(), show_workers=True,
                      show_data=True):
    # Avoid endless recursion in dump_works_at() and dump_organisation().
    seen |= set([com])
    dump_comments(com, tree)
    telephones(com, tree)
    dump_email(com, tree)
    dump_residences(com, tree)
    if show_workers:
        dump_works_at(com, tree, seen)
    if show_data:
        dump_data(com, tree)
    for link in com.links(outgoing & is_link(Has_department)):
        refonly = link.dept in seen
        if refonly:
            tree.add('-> ')
        dump_name(link.dept, tree, link, show_aka=not refonly)
        sub = tree.sub()
        dump_comments(link, sub)
        if not refonly:
            dump_organisation(link.dept, sub, seen, show_workers=show_workers,
                              show_data=show_data)

qual_home = multilang(en='home', es='casa')
qual_work = multilang(en='work', es='trab')

def dump_works_at(org, tree, seen):
    assert org in seen
    for link in sorted(org.links(incoming & is_link(Works_at))):
        refonly = link.person in seen
        if refonly:
            tree.add('-> ')
        else:
            tree.add('-- ')
        dump_name(link.person, tree, link, show_aka=not refonly)
        sub = tree.sub()
        dump_comments(link, sub)
        telephones(link, sub)
        dump_email(link, sub)
        if not refonly:
            dump_person(link.person, sub, seen,
                        show_work=False, show_data=False)

def dump_email(who, tree):
    for link in who.links(outgoing & is_link(Has_email)):
        if isinstance(link, At_work):
            tree.add(unicode(qual_work).capitalize(), ': ')
        elif isinstance(link, At_home):
            tree.add(unicode(qual_home).capitalize(), ': ')
        tree.set_wrapmargin()
        tree.add(link.email)
        wrap_comments(link.email, tree)
        wrap_comments(link, tree)
        tree.nl()

def wrap_comments(node, tree):
    comment = getattr(node, 'comment', None)
    if comment:
        tree.wrap('; ', comment)

def telephones(who, tree, qual=None, comment=None, bold=False,
               mobile=True, fixed=True, fax=True):
    typs = []
    if mobile:
        typs.append(Has_mobile)
    if fixed:
        typs.append(Has_fixed)
    if fax:
        typs.append(Has_fax)
    for typ in typs:
        for link in who.links(outgoing & is_link(typ)):
            telephone(link, tree, qual=qual, comment=comment, bold=bold)
            tree.nl()

def telephone(link, tree, qual=None, comment=None, bold=False):
    if isinstance(link, Has_mobile):
        tree.add(multilang(en='Mob', es=u'Móv'))
    elif isinstance(link, Has_fax):
        tree.add(u'Fax')
    else:
        assert isinstance(link, Has_fixed)
        tree.add(multilang(en='Tel', es=u'Tlf'))
    if qual:
        tree.add(' ', qual)
    elif isinstance(link, At_work):
        tree.add(' ', qual_work)
    elif isinstance(link, At_home):
        tree.add(' ', qual_home)
    tree.add(': ')
    tree.set_wrapmargin()
    tree.add(link.tel.relative(tree.local), bold=bold)
    wrap_comments(link.tel, tree)
    wrap_comments(link, tree)
    if comment:
        tree.wrap(' -- ', comment)

def dump_residences(who, tree):
    for link in who.links(outgoing & is_link(Resides_at)):
        tree.add(link.residence)
        tree.nl()
        sub = tree.sub()
        dump_comments(link, sub)
        telephones(link, sub)
        dump_comments(link.residence, sub)
        telephones(link.residence, sub)

def dump_data(who, tree):
    for link in who.links(is_link(With) | (outgoing & is_link(Is_in))):
        position = getattr(link, 'position', None)
        other = link.other(who)
        tree.add('* ')
        if position and isinstance(other, Organisation):
            tree.add(position, ', ')
            position = None
        if isinstance(link, Is_in):
            tree.add('in ')
        tree.add(other)
        if position:
            tree.add(', ', position)
        tree.nl()
        sub = tree.sub()
        dump_comments(link, sub)
        for data in link.nodes(incoming & is_link(Has_context)):
            sub.add(data)
            sub.nl()
            dump_comments(data, sub.sub())

def dump_comments(node, tree):
    for com in node.nodes(outgoing & is_link(Has_comment)):
        tree.add('; ')
        tree.set_wrapmargin()
        tree.wrap(unicode(com))
        tree.nl()

if __name__ == '__main__':
    main()
