#!/usr/bin/env python2.5
# vim: sw=4 sts=4 et fileencoding=latin1 nomod

'''Run the doctests in all of the listed modules.  If a module search path is
given with the --path option, then only that path is searched for the modules
listed on the command line.  If the --recursive option is given, then any
packages listed on the command line are tested, and also all modules and
packages contained within them.
'''

import sys
sys.path.pop(0)
import locale
import codecs
import os
import os.path
import cPickle as pickle
import errno
from optparse import OptionParser
import six.parse as parse
from six.test import run_doctest
from six.input import InputError
from six.model import *
from six.links import *
from six.sort import *
from itertools import ifilter

def main():
    locale.setlocale(locale.LC_ALL, '')
    lang, enc = locale.getlocale()
    op = OptionParser(usage=
        'Usage: %prog --doctest [doctest-options] [module ...]\n'
        '       %prog [options] [expr]')
    op.add_option('--doctest', action='callback', callback=opt_doctest,
                  help='run doctests (see --doctest --help for options)')
    op.add_option('-l', '--local',
                  action='store', type='string', dest='local',
                  help='output addresses and telephone numbers relative to '
                       'the country or area named LOCAL')
    op.add_option('-r', '--report',
                  action='store', type='string', dest='report',
                  help='select output report, REPORT is one of: dump, phone')
    op.add_option('-a', '--all',
                  action='store_true', dest='all',
                  help='print all possible values')
    op.add_option('-e', '--encode',
                  action='store', dest='string', dest='encoding',
                  help='use ENCODE as output encoding')
    op.set_defaults(report='dump')
    options, args = op.parse_args()
    path = os.path.join(os.environ['HOME'], 'me', 'contacts', 'nlist')
    cache = os.path.join(os.path.dirname(path),
                         '.six-cache-' + os.path.basename(path))
    # If the cache exists, attempt to read the model from it.  In the event
    # that it fails to read correctly, silently skip it and proceed to compile
    # the model from source, then save the compiled model in the cache.
    model = None
    if (    os.path.exists(cache) and
            (os.stat(path).st_mtime <= os.stat(cache).st_mtime) and
            (os.stat(sys.argv[0]).st_mtime <= os.stat(cache).st_mtime)):
        try:
            model = pickle.load(file(cache, 'r'))
        except StandardError:
            pass
    if model is None:
        model = Model()
        parser = ModelParser(model)
        try:
            for block in parse.blocks(parse.remove_comments(parse.lines(path))):
                parser.parse_block(block)
            parser.finish_parsing()
        except InputError, e:
            print >>sys.stderr, '%s: %s' % (os.path.basename(sys.argv[0]),
                                            str(e))
            sys.exit(1)
        finally:
            parser.finalise()
        try:
            os.remove(cache)
        except OSError, e:
            if e.errno != errno.ENOENT:
                raise
        orl = sys.getrecursionlimit()
        sys.setrecursionlimit(4000)
        pickle.dump(model, file(cache, 'w'))
        sys.setrecursionlimit(orl)
    # Parse command-line args as search expression.  If no args, then select
    # all nodes.
    try:
        local = None
        localn = None
        if options.local:
            try:
                local = model.lookup_place(options.local)
            except LookupError, e:
                raise ArgError(e, arg=options.local)
        elif 'SIX_LOCAL' in os.environ:
            try:
                local = model.lookup_place(os.environ['SIX_LOCAL'])
            except LookupError, e:
                raise EnvError(e, var='SIX_LOCAL')
        pred = None
        if len(args):
            for arg in args:
                if arg.startswith('='):
                    try:
                        kw = model.keyword(arg[1:])
                    except LookupError:
                        raise ArgError('no such keyword', arg=arg)
                    p = keyed_with(kw)
                elif arg.startswith('in:'):
                    try:
                        place = model.lookup_place(arg[3:])
                    except LookupError, e:
                        raise ArgError(e, arg=arg[3:])
                    p = from_node(NamedNode) & in_place(place)
                else:
                    p = name_imatches(arg.decode(enc))
                if pred is None:
                    pred = p
                else:
                    pred = pred & p
        # Print the selected report.
        try:
            report = globals()['report_' + options.report]
        except KeyError:
            raise ArgError('unsupported report %r' % options.report)
        report(options, model, pred, local, options.encoding or enc)
    except InputError, e:
        print >>sys.stderr, '%s: %s' % (os.path.basename(sys.argv[0]), str(e))
        sys.exit(2)

def opt_doctest(option, opt_str, value, parser, *args, **kwargs):
    op = OptionParser(usage=r'Usage: %prog --doctest [options] [module ...]')
    op.add_option('-v', '--verbose', action='store_true', dest='verbose',
                  help='print all tests and results as they are run')
    op.add_option('-r', '--recursive', action='store_true', dest='recursive',
                  help='recurse through packages')
    op.add_option('-p', '--path', action='store', type='string', dest='path',
                  help='search for modules in directory PATH')
    options, args = op.parse_args(args=parser.rargs)
    modules = args
    if not modules:
        modules = ['six']
        options.recursive = True
    status = 0
    for module_name in modules:
        if not run_doctest(module_name, options.path, recurse=options.recursive,
                           verbose=options.verbose):
            status = 1
    sys.exit(status)

class InputError(StandardError):
    pass

class ArgError(InputError):

    def __init__(self, msg, arg=None):
        StandardError.__init__(self, msg)
        self.arg = arg

    def __str__(self):
        r = []
        if self.arg is not None:
            r.append(repr(self.arg))
        r.append(StandardError.__str__(self))
        return ': '.join(r)

class EnvError(InputError):

    def __init__(self, msg, var=None):
        StandardError.__init__(self, msg)
        self.var = var

    def __str__(self):
        r = []
        if self.var is not None:
            r.append('env var %s' % self.var)
        r.append(StandardError.__str__(self))
        return ': '.join(r)

def report_dump(options, model, predicate, local, encoding):
    if predicate is None:
        predicate = (
            (from_node(Person) | from_node(Company) | from_node(Family)) &
            is_principal)
    sorter = Sorter()
    sorter.update(model.nodes(predicate))
    from six.output import Treebuf
    sorted = list(sorter.sorted()) # SortItem objects
    horizon = 12 # how far as a person will scan around
    # Remove entries that reference a nearby entry.
    for i, item in enumerate(sorted):
        if item is item.single:
            lim = 0
            for j in xrange(i - 1, -1, -1):
                if sorted[j].sortkey[:3] != item.sortkey[:3]:
                    break
                if sorted[j].node:
                    lim += 1
                    if lim > horizon:
                        break
                    if sorted[j].node is item.node:
                        sorted[j].node = None
    # Remove entries that reference the same entry as another nearby, prior
    # entry.
    for i, item in enumerate(sorted):
        if item is not item.single:
            lim = 0
            for j in xrange(i - 1, -1, -1):
                if sorted[j].sortkey[:3] != item.sortkey[:3]:
                    break
                if sorted[j].node:
                    lim += 1
                    if lim > horizon:
                        break
                    if sorted[j].node is item.node:
                        item.node = None
                        break
    tree = Treebuf(local=local)
    seen = set(sorter) # Node objects
    for group in uniqa_group(ifilter(lambda i: True or i.node, sorted),
                             key=lambda i: i.node):
        for item in group:
            if item.node is None:
                tree.nl()
                tree.add(item.key, ' OMITTED')
                tree.nl()
            elif item is not item.single:
                tree.nl()
                tree.add(item.key, ' -> ', item.single.key)
                tree.nl()
            elif isinstance(item.node, Family):
                tree.nl()
                dump_name(item.node, tree)
                dump_family(item.node, tree.sub(), seen)
            elif isinstance(item.node, Person):
                tree.nl()
                dump_name(item.node, tree)
                dump_person(item.node, tree.sub(), seen)
            elif isinstance(item.node, Department):
                com = item.node.node(incoming & is_link(Has_department))
                tree.nl()
                dump_name(item.node, tree,
                          qual=(', ', unicode(com)) if com else None)
                dump_organisation(item.node, tree.sub(), seen)
            elif isinstance(item.node, Organisation):
                tree.nl()
                dump_name(item.node, tree)
                dump_organisation(item.node, tree.sub(), seen)
    print unicode(tree).encode(encoding, 'replace')

def report_email(options, model, predicate, local, encoding):
    if predicate is None:
        predicate = from_node(Person) | from_node(Company) | from_node(Family)
        options.all = False
    sorter = Sorter()
    sorter.update(model.nodes(predicate))
    # Remove entries for families for which one or more of the heads was found.
    people = filter(lambda node: isinstance(node, Person), sorter)
    for person in people:
        for belongs_to in person.links(outgoing & is_link(Belongs_to)):
            if belongs_to.is_head:
                sorter.discard(belongs_to.family)
    for group in sorter.sorted():
        for item in group:
            if item is not item.single:
                continue
            node = item.node
            print_emails(node, encoding)
            stop = lambda node: False
            if isinstance(node, Organisation):
                pred = ((incoming & is_link(Works_at)) |
                        (outgoing & is_link(Belongs_to)) |
                        (outgoing & is_link(Resides_at)))
                if not options.all:
                    stop = lambda node: isinstance(node, Person)
            elif isinstance(node, Family):
                pred = ((outgoing & is_link(Works_at)) |
                        (incoming & is_link(Belongs_to)) |
                        (outgoing & is_link(Resides_at)))
                if not options.all:
                    stop = lambda node: isinstance(node, Organisation)
            else:
                assert isinstance(node, Person)
                pred = ((outgoing & is_link(Belongs_to)) |
                        (outgoing & is_link(Resides_at)) |
                        (outgoing & is_link(Works_at)))
                if not options.all:
                    stop = lambda node: isinstance(node, Organisation)
            for tup in sorted(node.find_nodes(pred, stop=stop), key=len):
                print_emails(tup[-1], encoding)

def print_emails(node, encoding):
    name = None
    if isinstance(node, NamedNode):
        name = unicode(node)
    elif isinstance(node, Link):
        if hasattr(node, 'person'):
            name = unicode(node.person)
        elif hasattr(node, 'who'):
            name = unicode(node.who)
        elif hasattr(node, 'org'):
            name = unicode(node.org)
    printed = 0
    for addr in node.nodes(outgoing & is_link(Has_email)):
        print addr.format(name, encoding)
        printed += 1
    return printed

def report_phone(options, model, predicate, local, encoding):
    if predicate is None:
        predicate = ((from_node(Person) | from_node(Company)) & is_principal)
    tkw = {'fax': False, 'bold': True}
    sorter = Sorter()
    sorter.update(model.nodes(predicate))
    # Remove entries for families for which one or more of the heads was found.
    people = filter(lambda node: isinstance(node, Person), sorter)
    for person in people:
        for belongs_to in person.links(outgoing & is_link(Belongs_to)):
            if belongs_to.is_head:
                sorter.discard(belongs_to.family)
    from six.output import Treebuf
    tree = Treebuf(local=local)
    for group in sorter.sorted():
        for item in group:
            if item is not item.single:
                continue
            node = item.node
            tree.nl()
            sub = tree.sub()
            if isinstance(node, Person):
                tree.add(unicode(node), underline=True)
                tree.nl()
                dump_comments(node, sub)
                telephones(node, sub, **tkw)
                for tup in node.find_nodes(
                        (outgoing & is_link(Belongs_to)) |
                        (outgoing & is_link(Resides_at)) |
                        (outgoing & is_link(Works_at))):
                    telephones_qual(tup, sub, **tkw)
            elif isinstance(node, Family):
                tree.add(unicode(node), underline=True)
                tree.nl()
                dump_comments(node, sub)
                telephones(node, sub, **tkw)
                for tup in node.find_nodes(outgoing & is_link(Resides_at)):
                    comment = []
                    for node1 in tup:
                        if isinstance(node1, Resides_at):
                            comment.append(node1.residence.lines[0])
                    telephones(tup[-1], sub, comment=', '.join(comment), **tkw)
                for link in sorted(node.links(incoming & is_link(Belongs_to))):
                    sub.add(link.person.familiar_name(), underline=True)
                    sub.nl()
                    subsub = sub.sub()
                    telephones(link, subsub, **tkw)
                    telephones(link.person, subsub, **tkw)
                    for tup in link.person.find_nodes(
                            (outgoing & is_link(Works_at)) |
                            (outgoing & is_link(Resides_at))):
                        telephones_qual(tup, subsub, **tkw)
            elif isinstance(node, Organisation):
                tree.add(unicode(node), underline=True)
                if isinstance(node, Department):
                    link = node.link(incoming & is_link(Has_department))
                    if link:
                        tree.add(', ', unicode(link.company))
                tree.nl()
                dump_comments(node, sub)
                telephones(node, sub, **tkw)
                telephones_org(node, sub, **tkw)
                for dept in node.nodes(outgoing & is_link(Has_department)):
                    sub.add(unicode(dept), underline=True)
                    sub.nl()
                    subsub = sub.sub()
                    telephones(dept, subsub, **tkw)
                    telephones_org(dept, subsub, **tkw)
    print unicode(tree).encode(encoding, 'replace')

def telephones_org(org, tree, **tkw):
    for tup in org.find_nodes(outgoing & is_link(Resides_at)):
        comment = []
        for node1 in tup:
            if isinstance(node1, Resides_at):
                comment.append(node1.residence.lines[0])
        telephones(tup[-1], tree, comment=', '.join(comment), **tkw)
    for link in sorted(org.links(incoming & is_link(Works_at))):
        tree.add(unicode(link.person), underline=True)
        if link.position:
            tree.add(', ', unicode(link.position))
        tree.nl()
        sub = tree.sub()
        telephones(link, sub, **tkw)
        telephones(link.person, sub, **tkw)
        for tup in link.person.find_nodes(
                (outgoing & is_link(Belongs_to)) |
                (outgoing & is_link(Resides_at))):
            telephones_qual(tup, sub, **tkw)

def telephones_qual(tup, tree, **kwargs):
    qual = None
    comment = []
    for node in tup:
        if qual is None:
            dept = None
            if isinstance(node, Resides_at):
                qual = qual_home
                comment.append(node.residence.lines[0])
            elif isinstance(node, Works_at):
                qual = qual_work
                if node.position and node is tup[-1]:
                    comment.append(node.position)
                comment.append(unicode(node.org))
                if isinstance(node.org, Department):
                    dept = node.org
            elif isinstance(node, Department):
                dept = node
            elif isinstance(node, Has_department) and node.dept is dept:
                dept = None
                comment.append(unicode(node.company))
            # If we finished at a Department node, we'd better print the name
            # of the Company too.
            if dept:
                link = dept.link(incoming & is_link(Has_department))
                if link:
                    comment.append(unicode(link.company))
    telephones(tup[-1], tree, qual=qual, comment=', '.join(comment), **kwargs)

from six.multilang import multilang
from six.node import *
from six.person import *
from six.family import *
from six.org import *
from six.world import *
from six.address import *
from six.telephone import *
from six.email import *
from six.keyword import *
from six.data import *
from six.comment import *
from six.uniq import uniq, uniqa_group

def dump_name(node, tree, qual=None):
    prefix = ''
    for name in uniq(node.names()):
        tree.add(prefix, name)
        if qual:
            tree.add(*qual)
            qual = None
        tree.nl()
        if not prefix:
            prefix = '= '
            tree = tree.sub()

def dump_person(per, tree, seen=frozenset(), show_family=True, show_work=True,
                show_data=True):
    dump_comments(per, tree)
    if per.birthday():
        tree.add(unicode(multilang(en='Birthday', es='F.nac.')))
        tree.add(': ')
        tree.add(unicode(per.birthday()))
        tree.nl()
    telephones(per, tree)
    dump_email(per, tree)
    dump_residences(per, tree)
    # Avoid endless recursion in dump_family() and dump_organisation().
    seen |= set([per])
    if show_family:
        for link in per.links(outgoing & is_link(Belongs_to)):
            refonly = link.family in seen
            if refonly:
                tree.add('-> ')
            else:
                tree.add('-- ')
            tree.add(unicode(link.family))
            tree.nl()
            sub = tree.sub()
            dump_comments(link, sub)
            telephones(link, sub)
            dump_email(link, sub)
            if not refonly:
                dump_family(link.family, sub, seen,
                            show_members=False, show_data=False)
    if show_work:
        for link in per.links(outgoing & is_link(Works_at)):
            refonly = link.org in seen
            if refonly:
                tree.add('-> ')
            else:
                tree.add('-- ')
            if link.position:
                tree.add(link.position, ', ')
            tree.add(unicode(link.org))
            tree.nl()
            sub = tree.sub()
            dump_comments(link, sub)
            telephones(link, sub)
            dump_email(link, sub)
            if not refonly:
                dump_organisation(link.org, sub, seen,
                                  show_workers=False, show_data=False)
    if show_data:
        dump_data(per, tree)

def dump_family(fam, tree, seen=frozenset(), show_members=True, show_data=True):
    # Avoid endless recursion in dump_person().
    seen |= set([fam])
    dump_comments(fam, tree)
    dump_residences(fam, tree)
    telephones(fam, tree)
    dump_email(fam, tree)
    if show_data:
        dump_data(fam, tree)
    if show_members:
        for link in sorted(fam.links(incoming & is_link(Belongs_to))):
            refonly = link.person in seen
            if refonly:
                tree.add('-> ')
                tree.add(unicode(link.person))
                tree.nl()
                sub = tree.sub()
                dump_comments(link, sub)
                telephones(link, sub)
                dump_email(link, sub)
            else:
                tree.add('-- ')
                dump_name(link.person, tree)
                sub = tree.sub()
                dump_comments(link, sub)
                telephones(link, sub)
                dump_email(link, sub)
                dump_person(link.person, sub, seen, show_family=False,
                            show_data=show_data)

def dump_organisation(com, tree, seen=frozenset(), show_workers=True,
                      show_data=True):
    # Avoid endless recursion in dump_works_at() and dump_organisation().
    seen |= set([com])
    dump_comments(com, tree)
    telephones(com, tree)
    dump_email(com, tree)
    dump_residences(com, tree)
    if show_workers:
        dump_works_at(com, tree, seen)
    if show_data:
        dump_data(com, tree)
    for link in com.links(outgoing & is_link(Has_department)):
        refonly = link.dept in seen
        if refonly:
            tree.add('-> ')
        tree.add(unicode(link.dept))
        tree.nl()
        sub = tree.sub()
        dump_comments(link, sub)
        if not refonly:
            dump_organisation(link.dept, sub, seen, show_workers=show_workers,
                              show_data=show_data)

qual_home = multilang(en='home', es='casa')
qual_work = multilang(en='work', es='trab')

def dump_works_at(org, tree, seen):
    assert org in seen
    for link in sorted(org.links(incoming & is_link(Works_at))):
        refonly = link.person in seen
        if refonly:
            tree.add('-> ')
        else:
            tree.add('-- ')
        tree.add(unicode(link.person))
        if link.position:
            tree.add(', ', link.position)
        tree.nl()
        sub = tree.sub()
        dump_comments(link, sub)
        telephones(link, sub)
        dump_email(link, sub)
        if not refonly:
            dump_person(link.person, sub, seen,
                        show_work=False, show_data=False)

def dump_email(who, tree):
    for link in who.links(outgoing & is_link(Has_email)):
        if isinstance(link, At_work):
            tree.add(unicode(qual_work).capitalize(), ': ')
        elif isinstance(link, At_home):
            tree.add(unicode(qual_home).capitalize(), ': ')
        tree.set_wrapmargin()
        tree.add(unicode(link.email))
        wrap_comments(link.email, tree)
        wrap_comments(link, tree)
        tree.nl()

def wrap_comments(node, tree):
    comment = getattr(node, 'comment', None)
    if comment:
        tree.wrap('; ', comment)

def telephones(who, tree, qual=None, comment=None, bold=False,
               mobile=True, fixed=True, fax=True):
    typs = []
    if mobile:
        typs.append(Has_mobile)
    if fixed:
        typs.append(Has_fixed)
    if fax:
        typs.append(Has_fax)
    for typ in typs:
        for link in who.links(outgoing & is_link(typ)):
            telephone(link, tree, qual=qual, comment=comment, bold=bold)
            tree.nl()

def telephone(link, tree, qual=None, comment=None, bold=False):
    if isinstance(link, Has_mobile):
        tree.add(unicode(multilang(en='Mob', es=u'Móv')))
    elif isinstance(link, Has_fax):
        tree.add(u'Fax')
    else:
        assert isinstance(link, Has_fixed)
        tree.add(unicode(multilang(en='Tel', es=u'Tlf')))
    if qual:
        tree.add(' ', unicode(qual))
    elif isinstance(link, At_work):
        tree.add(' ', unicode(qual_work))
    elif isinstance(link, At_home):
        tree.add(' ', unicode(qual_home))
    tree.add(': ')
    tree.set_wrapmargin()
    tree.add(link.tel.relative(tree.local), bold=bold)
    wrap_comments(link.tel, tree)
    wrap_comments(link, tree)
    if comment:
        tree.wrap(' -- ', comment)

def dump_residences(who, tree):
    for link in who.links(outgoing & is_link(Resides_at)):
        tree.add(unicode(link.residence))
        tree.nl()
        sub = tree.sub()
        dump_comments(link, sub)
        telephones(link, sub)
        dump_comments(link.residence, sub)
        telephones(link.residence, sub)

def dump_data(who, tree):
    for link in who.links(is_link(With) | (outgoing & is_link(Is_in))):
        position = getattr(link, 'position', None)
        other = link.other(who)
        tree.add('* ')
        if position and isinstance(other, Organisation):
            tree.add(position, ', ')
            position = None
        if isinstance(link, Is_in):
            tree.add('in ')
        tree.add(unicode(other))
        if position:
            tree.add(', ', position)
        tree.nl()
        sub = tree.sub()
        dump_comments(link, sub)
        for data in link.nodes(incoming & is_link(Has_context)):
            sub.add(unicode(data))
            sub.nl()
            dump_comments(data, sub.sub())

def dump_comments(node, tree):
    for com in node.nodes(outgoing & is_link(Has_comment)):
        tree.add('; ')
        tree.set_wrapmargin()
        tree.wrap(unicode(com))
        tree.nl()

if __name__ == '__main__':
    main()
